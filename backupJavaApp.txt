/*   NOME: Elisa Martins dos Santos  NÚMERO USP: 10346721    */

package teste;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class App {

    public static void main(String[] args) throws IOException {
        FileReader arquivo = null; //Cria a variável arquivo, do tipo FileReader
        BufferedReader lerArquivo = null; //Cria a variável lerArquivo, do tipo BufferedReader

        try {
             arquivo = new FileReader(args[0]); //Copia para a memória do JAVA o arquivo.txt que será passado pelo professor na varável "arquivo" |(de tipo FileReader)
             lerArquivo = new BufferedReader(arquivo); //Lê a variável "arquivo" (de tipo FileReader) que armazena o arquivo.txt passado pelo professor
            

		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
            e.printStackTrace();
            return; 
        }
        
        String entrada = lerArquivo.readLine(); //Lê a primeira linha do arquivo.txt passado pelo professor e armazena na variável entrada (de Tipo String)
        String[] definirMatriz = entrada.split(" "); //Coloca a variável "entrada" em um array de Strings (definirMatriz) e transforma cada item da entrada em um item do array
        int linhas = Integer.parseInt(definirMatriz[0]); //Pega o primeiro item do Array "definirMatriz" e coloca na variável "linhas", essa variável irá determinar a quantidade de linhas que a Matriz que representa o Labirinto terá
        int colunas = Integer.parseInt(definirMatriz[1]); //Pega o segundo item do Array "definirMatriz" e coloca na vriável "colunas", essa variável irá determinar a quantidade de colunas que a Matriz que representa o Labirinto terá
        char[][] labirinto = new char [linhas][colunas]; //Cria a Matriz de char "labirinto" cuja quantidade de linhas será determinada pela variável "linhas" e cuja quantidade de colunas será determinada pela variável "colunas"
        for (int contadorLinhas = 0; contadorLinhas < linhas; contadorLinhas++) { //Contador para a quantidade de linhas, irá povoar as linhas da labirinto com os caracteres especificados pelo professor no arquivo.txt
            char[] auxiliar = lerArquivo.readLine().toCharArray(); //String que irá ser povoada com as linhas que irão representar o labirinto, serve para auxiliar na construção da matriz. OBS: Foi gerado um Array de Strings com, cada posição, contendo apenas um caractere. 
            for (int contadorColunas = 0; contadorColunas < colunas; contadorColunas++) { //Conatador para a quantidade de colunas, irá povoar as colunas da matriz com os caracteres especificados pelo professor no arquivo.txt 
                labirinto [contadorLinhas][contadorColunas] = auxiliar[contadorColunas]; //Povoa a matriz com o auxílio da String auxiliar. OBS: O "charAt(n)" pega o caractere na posição n da String e transforma em Char, como as Strings possuem apenas um caractere =, a posição dada é 0. 
            }
        }
        int quantidadeDeItens = Integer.parseInt(lerArquivo.readLine()); //Armazena na variável quantidadeDeItens, o número que representa a quantidade de itens espalhados pelo labirinto do arquivo.txt passado pelo professor
        int[][] caracteristicasItens = new int [quantidadeDeItens][4]; //Cria uma matriz para armazenar as características dos itens espalhados pelo labirinto. A quantidade de linhas dessa matriz armazena a quantidade de items presentes, então sempre será determinada pela varíavel "quantidadeDeItens". A quantidade de colunas dessa matriz será fixa, já que cada item possuirá sempre quatro características, logo a quantidade de colunas será sempre 4.
        for (int contadorLinhas = 0; contadorLinhas < quantidadeDeItens; contadorLinhas++) {
            String[] auxiliar = lerArquivo.readLine().split(" ");
            for (int contadorColunas = 0; contadorColunas < 4; contadorColunas++) {
                caracteristicasItens [contadorLinhas][contadorColunas] = Integer.parseInt(auxiliar[contadorColunas]);
            }
        }
        
        /* OBS: Lembrar que:
        - A primeira coluna da matriz "caracteristicasItens" sempre mostra a linha da matriz no qual o item se encontra,
        - A segunda coluna da matriz "caracteristicasItens" sempre mostra a coluna da matriz na qual o item se encontra,
        - A terceira coluna da matriz "caracteristicasItens" sempre mostra o valor do item,
        - A quarta coluna da matriz "caracteristicasItens" sempre mostra o peso do item,                                */

        int capacidadeDeCargaMochila = Integer.parseInt(lerArquivo.readLine()); //Variável que guardará a capacidade da mochila do Explorador
        int[] coordenadasInicio = new int [2]; //Array que armazenará a posição (linha e coluna da matriz) de onde o explorador começará sua jornada
        int[] coordenadasFinal = new int [2]; //Array que armazenará a posição (linha e coluna da matriz) de onde o explorador estará ao final de sua jornada

        String[] auxiliar = lerArquivo.readLine().split(" "); //String auxiliar para ajudar a povoar os arrays "coordenadasInicio" e "coordenadasFim"

        coordenadasInicio[0] = Integer.parseInt(auxiliar[0]); //Guarda a linha da posição de onde o Explorador começará sua jornada
        coordenadasInicio[1] = Integer.parseInt(auxiliar[1]); //Guarda a coluna da posição de onde o Explorador começará sua jornada
        
        auxiliar = lerArquivo.readLine().split(" "); //String auxiliar para ajudar a povoar os arrays "coordenadasInicio" e "coordenadasFim"
        coordenadasFinal[0] = Integer.parseInt(auxiliar[0]); //Guarda a linha da posição onde o Explorador estará ao final de sua jornada
        coordenadasFinal[1] = Integer.parseInt(auxiliar[1]); //Guarda a coluna da posição onde o Explordor estará ao final de sua jornada 
        
        int[][] labirintoInt = coverterParaInt(labirinto);  
        
        lerArquivo.close();
        Labirinto lab = new Labirinto();
        lab.labirintoInt = labirintoInt.clone();
        caminhoMaisCurto(lab, coordenadasInicio, coordenadasFinal, 1, ' ');
        imprimirCaminhoMaisCurto(labirintoInt, coordenadasFinal);
        
    }

    private static void imprimirCaminhoMaisCurto(int[][] labirintoInt, int[] coordenadasFinal) {
        int[][] caminhoMaisCurtoQueSeraImpresso = new int [labirintoInt[coordenadasFinal[0]][coordenadasFinal[1]]][2];
        int x = coordenadasFinal[0];
        int y = coordenadasFinal[1];

        for (int contador = 0; labirintoInt[x][y] != 1; contador++) {
            
            //Para a Direita:
            if (labirintoInt[x][y+1] < labirintoInt[x][y]) {
                caminhoMaisCurtoQueSeraImpresso[contador][0] = x;
                caminhoMaisCurtoQueSeraImpresso[contador][1] = y;
                y = y + 1;
            }

            //Para Baixo:
            if (labirintoInt[x+1][y] < labirintoInt[x][y]) {
                caminhoMaisCurtoQueSeraImpresso[contador][0] = x;
                caminhoMaisCurtoQueSeraImpresso[contador][1] = y;
                x = x + 1;
            }

            //Para a Esquerda:
            if (labirintoInt[x][y-1] < labirintoInt[x][y]) {
                caminhoMaisCurtoQueSeraImpresso[contador][0] = x;
                caminhoMaisCurtoQueSeraImpresso[contador][1] = y;
                y = y - 1;
            }

            //Para Cima:
            if (labirintoInt[x-1][y] < labirintoInt[x][y]) {
                caminhoMaisCurtoQueSeraImpresso[contador][0] = x;
                caminhoMaisCurtoQueSeraImpresso[contador][1] = y;
                x = x - 1;
            }
        }
       
        System.out.println(caminhoMaisCurtoQueSeraImpresso.length);
        for (int contador2 = caminhoMaisCurtoQueSeraImpresso.length-1; contador2 >= 0; contador2--) {
            System.out.println(caminhoMaisCurtoQueSeraImpresso[contador2][0] + " " + caminhoMaisCurtoQueSeraImpresso[contador2][1]);
        }

        System.out.println("0 0 0");
	}

	private static int[][] coverterParaInt(char[][] labirinto) {
        int[][] mapa = new int[labirinto.length][labirinto[0].length];

        for (int contador = 0; contador < labirinto.length; contador++) {
            for (int contador2 = 0; contador2 < labirinto[0].length; contador2++) {
                if (labirinto[contador][contador2] == 'X') mapa[contador][contador2] = 0;
                else mapa[contador][contador2] = 1;
            }
        }

		return mapa;
	}

	public static void caminhoMaisCurto(Labirinto labirinto, int[] coordenadaAtual, int[] coordenadasFinal, int posicaoAnterior, char flag) {
        if (coordenadaAtual[0] >= 0 && coordenadaAtual[1] >= 0 && coordenadaAtual[0] < labirinto.labirintoInt.length && coordenadaAtual[1] < labirinto.labirintoInt[0].length) {
            if(labirinto.labirintoInt[coordenadaAtual[0]][coordenadaAtual[1]] == -1) return;
            if(coordenadaAtual[0] == coordenadasFinal[0] && coordenadaAtual[1] == coordenadasFinal[1]) return;
            if (posicaoAnterior+1 < labirinto.labirintoInt[coordenadaAtual[0]][coordenadaAtual[1]] || labirinto.labirintoInt[coordenadaAtual[0]][coordenadaAtual[1]] == 0) 
                labirinto.changePlace(posicaoAnterior, coordenadaAtual[0], coordenadaAtual[1]);
            int[] auxiliar = new int[2];
            //Para a Direita:

            if (flag != 'E'){
                auxiliar[0] = coordenadaAtual[0];
                auxiliar[1] = coordenadaAtual[1]+1;
                flag = 'D';
                caminhoMaisCurto(labirinto, auxiliar, coordenadasFinal, posicaoAnterior+1, flag);
                imprimirLabirinto(labirinto);
            }
            //Para Baixo:
            if (flag != 'C'){ 
                auxiliar[0] = coordenadaAtual[0]+1;
                auxiliar[1] = coordenadaAtual[1];
                flag = 'B';
                caminhoMaisCurto(labirinto, auxiliar, coordenadasFinal, posicaoAnterior+1, flag);
                imprimirLabirinto(labirinto);
            }
            //Para a Esquerda:
            if (flag != 'D'){
                auxiliar[0] = coordenadaAtual[0];
                auxiliar[1] = coordenadaAtual[1]-1;
                flag = 'E';
                caminhoMaisCurto(labirinto, auxiliar, coordenadasFinal, posicaoAnterior+1, flag);
                imprimirLabirinto(labirinto);
            }
            //Para Cima:
            if (flag != 'B'){
                auxiliar[0] = coordenadaAtual[0]-1;
                auxiliar[1] = coordenadaAtual[1];
                flag = 'C';
                caminhoMaisCurto(labirinto, auxiliar, coordenadasFinal, posicaoAnterior+1, flag);
                imprimirLabirinto(labirinto);
            }
        }

        return;

    }

	private static void imprimirLabirinto(Labirinto labirinto) {
        for(int aux = 0; aux < labirinto.labirintoInt.length; aux++){
            for(int aux2 = 0; aux2 < labirinto.labirintoInt[0].length; aux2++){
                System.out.print(labirinto.labirintoInt[aux][aux2]);
            }
            System.out.println();
        }
	}

}